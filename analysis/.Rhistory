if(nodeLabelsBy=="name"){
item = 1
}
if(nodeLabelsBy=="iso"){
item = 3
}
}
X = gsub("\\]","[",X)
return(
sapply(strsplit(X,"\\["),function(z){
if(length(z)>=item){
return(z[item])
} else{
return("")
}
}))
}
bind.tip<-function(tree,tip.label,edge.length=NULL,where=NULL){
if(is.null(where)) where<-length(tree$tip)+1
tip<-list(edge=matrix(c(2,1),1,2),
tip.label=tip.label,
edge.length=edge.length,
Nnode=1)
class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
for(nx in phy$node.label[phy$node.label!='']){
phy = setNodeToTip(nx,phy)
}
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
#' Convert golottolog tip labels
#'
#' @param X vector of labels.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @return vector of node labels
#' @keywords Glottolog
#' @examples
#' phy$tip.label = editGlottologTipLabels(phy$tip.label,"glottoid")
#'
editGlottologTipLabels = function(X, nodeLabelsBy="glottoid"){
item = 2 # glottoid by default
if(is.numeric(nodeLabelsBy)){
item = nodeLabelsBy
} else{
if(nodeLabelsBy=="name"){
item = 1
}
if(nodeLabelsBy=="iso"){
item = 3
}
}
X = gsub("\\]","[",X)
return(
sapply(strsplit(X,"\\["),function(z){
if(length(z)>=item){
return(z[item])
} else{
return("")
}
}))
}
bind.tip<-function(tree,tip.label,edge.length=NULL,where=NULL){
if(is.null(where)) where<-length(tree$tip)+1
tip<-list(edge=matrix(c(2,1),1,2),
tip.label=tip.label,
edge.length=edge.length,
Nnode=1)
class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
nodesToTips = function(phy, nodesToFix = phy$node.label[phy$node.label!='']){
for(nx in nodesToFix){
phy = setNodeToTip(nx,phy)
}
return(phy)
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
phy = nodesToTips(phy)
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
?readLines
phy <- getGlottologTree("atla1278","glottoid", langNodesToTips = T)
phy
'gola1255' %in% phy$tip.labels
plot(phy)
d = read.csv("~/Downloads/midata8613.csv")
head(d)
d$X.Date
as.Date(d$X.Date)
as.Date(as.character(d$X.Date))
?as.Date(as.character(d$X.Date))
as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
plot(d$Balance,d$date)
plot(d$Balance~d$date)
plot(d$date,d$Balance)
plot(d$date,d$Balance, type = 'line')
head(d)
head(d$Balance)
d$Balance = as.numeric(d$Balance)
d$Balance
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
as.numeric(as.character(substring(d$Balance,2))
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
substring(d$Balance,2)
?substring(d$Balance,2)
X = head(d$Balance)
X
d$Balance = as.character(d$Balance)
d$Balance
X = head(d$Balance)
substring(X,2)
substring(X,1)
substring(X,4)
substring(X,3)
as.numeric(as.character(substring(d$Balance,3)))
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$Balance = as.character(d$Balance)
d$Balance = as.numeric(as.character(substring(d$Balance,3)))
plot(d$date,d$Balance, type = 'line')
abline(as.Date(2017-01-01))
abline(v=as.Date(2017-01-01))
abline(h=as.Date(2017-01-01))
as.Date(2017-01-01)
abline(h=as.Date("2017-01-01"))
abline(v=as.Date("2017-01-01"))
abline(v=as.Date("2017-02-01"))
abline(v=as.Date("2017-03-01"))
d
d[45:46,]
factor(10)
factorial(10)
factorial(20)
numberOfSamples = 137
numberOfSamples/2
68 + 68
d = read.csv("~/Documents/MPI/LuisM_K_Pronoun/data/Alldata_simple.csv", stringsAsFactors = F)
head(d)
names(d)
g = read.csv("~/Documents/MPI/Glottolog/glottolog-languoid.csv/languoid.csv",stringsAsFactors = F)
names(g)
g$family = g[match(g$family_pk,g$pk),]$name
head(g$id)
d$family = g[match(d$glotto,g$id),]$family
head(d$family)
table(d$family)
d2 = d[d$family=="Uto-Aztecan",]
table(d2$meaning.id)
table(d2$Language)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 10)
head(d)
plot(d$posterior)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 20000)
plot(d$posterior)
plot(log(d$posterior))
plot(log(absd$posterior))
plot(log(abs(d$posterior)))
plot((d$posterior))
plot((d$posterior[3:nrow(d)]))
library(RColorBrewer)
RColorBrewer::display.brewer.all()
?RColorBrewer::display.brewer.all()
?display.brewer.all()
RColorBrewer::display.brewer.all(colorblindFriendly=T)
?display.brewer.all(colorblindFriendly=T)
brewer.pal(4,'Dark2')
plot(1:4,col=brewer.pal(4,'Dark2'),pch=15, cex=4)
plot(1:4,col=brewer.pal(4,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Dark2'),pch=15, cex=4)
pi
pi*0.5
library(ape)
setwd("~/Documents/MPI/ClimateAndLanguage/PHOIBLE_Replication/analysis/")
source("fitPagel.r")
runDiscrete = function(tree,x,y, iQ, dQ){
# fit discrete
fit.ape = NA
try(fit.ape<-fitPagel(tree,x,y,iQ=iQ,dQ=dQ,method='ace'))
return(list(list(fit.ape,table(x,y),qx)))
}
# single-rate model
iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
# differet rates for complex -> simple in humid and dry conditions
dQ =matrix(c(0,1,2,0,3,0,0,5,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
tree = read.nexus("../data/grollemund_et_al2015-d-place.NEXUS")
tree.t = read.csv("../data/grollemund_et_al2015-d-place_Taxa.csv", stringsAsFactors = F)
tree$tip.label = tree.t[match(tree$tip.label, tree.t$taxon),]$glottocode
p = read.csv("../data/phoibleTonesAndHumidity.csv", stringsAsFactors = F)
load('../../Phylogenetics/GlottologTree/ANU_Data.rDat')
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
anu$glottocode = g[match(anu$iso, g$hid),]$id
anu = anu[!is.na(anu$glottocode),]
anu = anu[!anu$glottocode %in% p$Glottocode,]
names(anu)[names(anu) %in% c("Number.of.tones","glottocode")] = c("Tones","Glottocode")
comb = rbind(anu[,c("Glottocode","Tones",'specH.mean')],
p[,c("Glottocode","Tones",'specH.mean')])
tree = drop.tip(tree, tree$tip.label[!tree$tip.label %in% comb$Glottocode])
tones = comb[match(tree$tip.label, comb$Glottocode),]$Tones
names(tones) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
humidity = comb[match(tree$tip.label, comb$Glottocode),]$specH.mean
names(humidity) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
tones.bin = tones>=3
# Estimate quantiles from whole distribution
quantilesToRun = seq(from=0.05,to=1,by=0.05)
quantiles = quantile(comb$specH.mean, quantilesToRun)
res = data.frame()
qx =  quantiles[4]
qx
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
resx
qx = quantiles[5]
qx
qx = quantiles[6]
qx
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
# run discrete
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
resx
DrawRateGraph2(resx)
DrawRateGraph2(resx[[1]])
resx
z = resx[[1]]
z
z = resx[[1]][[1]]
z
z = resx[[1]][[1]][[1]]
z
DrawRateGraph2(resx[[1]][[1]][[1]])
DrawRateGraph2(resx[[1]][[1]])
library(ape)
setwd("~/Documents/MPI/ClimateAndLanguage/PHOIBLE_Replication/analysis/")
source("fitPagel.r")
runDiscrete = function(tree,x,y, iQ, dQ){
# fit discrete
fit.ape = NA
try(fit.ape<-fitPagel(tree,x,y,iQ=iQ,dQ=dQ,method='ace'))
return(list(list(fit.ape,table(x,y),qx)))
}
# single-rate model
iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
# differet rates for complex -> simple in humid and dry conditions
dQ =matrix(c(0,1,2,0,3,0,0,5,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
tree = read.nexus("../data/grollemund_et_al2015-d-place.NEXUS")
tree.t = read.csv("../data/grollemund_et_al2015-d-place_Taxa.csv", stringsAsFactors = F)
tree$tip.label = tree.t[match(tree$tip.label, tree.t$taxon),]$glottocode
p = read.csv("../data/phoibleTonesAndHumidity.csv", stringsAsFactors = F)
load('../../Phylogenetics/GlottologTree/ANU_Data.rDat')
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
anu$glottocode = g[match(anu$iso, g$hid),]$id
anu = anu[!is.na(anu$glottocode),]
anu = anu[!anu$glottocode %in% p$Glottocode,]
names(anu)[names(anu) %in% c("Number.of.tones","glottocode")] = c("Tones","Glottocode")
comb = rbind(anu[,c("Glottocode","Tones",'specH.mean')],
p[,c("Glottocode","Tones",'specH.mean')])
tree = drop.tip(tree, tree$tip.label[!tree$tip.label %in% comb$Glottocode])
tones = comb[match(tree$tip.label, comb$Glottocode),]$Tones
names(tones) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
humidity = comb[match(tree$tip.label, comb$Glottocode),]$specH.mean
names(humidity) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
tones.bin = c("simple","complex")[tones>=3]
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
library(ape)
setwd("~/Documents/MPI/ClimateAndLanguage/PHOIBLE_Replication/analysis/")
source("fitPagel.r")
runDiscrete = function(tree,x,y, iQ, dQ){
# fit discrete
fit.ape = NA
try(fit.ape<-fitPagel(tree,x,y,iQ=iQ,dQ=dQ,method='ace'))
return(list(list(fit.ape,table(x,y),qx)))
}
# single-rate model
iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
# differet rates for complex -> simple in humid and dry conditions
dQ =matrix(c(0,1,2,0,3,0,0,5,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
tree = read.nexus("../data/grollemund_et_al2015-d-place.NEXUS")
tree.t = read.csv("../data/grollemund_et_al2015-d-place_Taxa.csv", stringsAsFactors = F)
tree$tip.label = tree.t[match(tree$tip.label, tree.t$taxon),]$glottocode
p = read.csv("../data/phoibleTonesAndHumidity.csv", stringsAsFactors = F)
load('../../Phylogenetics/GlottologTree/ANU_Data.rDat')
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
anu$glottocode = g[match(anu$iso, g$hid),]$id
anu = anu[!is.na(anu$glottocode),]
anu = anu[!anu$glottocode %in% p$Glottocode,]
names(anu)[names(anu) %in% c("Number.of.tones","glottocode")] = c("Tones","Glottocode")
comb = rbind(anu[,c("Glottocode","Tones",'specH.mean')],
p[,c("Glottocode","Tones",'specH.mean')])
tree = drop.tip(tree, tree$tip.label[!tree$tip.label %in% comb$Glottocode])
tones = comb[match(tree$tip.label, comb$Glottocode),]$Tones
names(tones) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
humidity = comb[match(tree$tip.label, comb$Glottocode),]$specH.mean
names(humidity) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
tones.bin = c("simple","complex")[tones>=3]
tones.bin
tones.bin = c("simple","complex")[1+as.numeric(tones>=3)]
library(ape)
setwd("~/Documents/MPI/ClimateAndLanguage/PHOIBLE_Replication/analysis/")
source("fitPagel.r")
runDiscrete = function(tree,x,y, iQ, dQ){
# fit discrete
fit.ape = NA
try(fit.ape<-fitPagel(tree,x,y,iQ=iQ,dQ=dQ,method='ace'))
return(list(list(fit.ape,table(x,y),qx)))
}
# single-rate model
iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
# differet rates for complex -> simple in humid and dry conditions
dQ =matrix(c(0,1,2,0,3,0,0,5,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
tree = read.nexus("../data/grollemund_et_al2015-d-place.NEXUS")
tree.t = read.csv("../data/grollemund_et_al2015-d-place_Taxa.csv", stringsAsFactors = F)
tree$tip.label = tree.t[match(tree$tip.label, tree.t$taxon),]$glottocode
p = read.csv("../data/phoibleTonesAndHumidity.csv", stringsAsFactors = F)
load('../../Phylogenetics/GlottologTree/ANU_Data.rDat')
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
anu$glottocode = g[match(anu$iso, g$hid),]$id
anu = anu[!is.na(anu$glottocode),]
anu = anu[!anu$glottocode %in% p$Glottocode,]
names(anu)[names(anu) %in% c("Number.of.tones","glottocode")] = c("Tones","Glottocode")
comb = rbind(anu[,c("Glottocode","Tones",'specH.mean')],
p[,c("Glottocode","Tones",'specH.mean')])
tree = drop.tip(tree, tree$tip.label[!tree$tip.label %in% comb$Glottocode])
tones = comb[match(tree$tip.label, comb$Glottocode),]$Tones
names(tones) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
humidity = comb[match(tree$tip.label, comb$Glottocode),]$specH.mean
names(humidity) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
tones.bin = c("simple","complex")[1+as.numeric(tones>=3)]
quantilesToRun = seq(from=0.05,to=1,by=0.05)
quantiles = quantile(comb$specH.mean, quantilesToRun)
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
tones.bin
humidity.bin
tones.bin
names(tones.bin) = names(tones)
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
DrawRateGraph2(resx[[1]][[1]])
rex
resx
qx = quantiles[4]
qx
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
# run discrete
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
qx = quantiles[5]
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
# run discrete
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
DrawRateGraph2(resx[[1]][[1]])
resx
DrawRateGraph2(resx[[1]][[1]], independent = T)
DrawRateGraph2(resx[[1]][[1]])
title("Independnet")
title("Independnet", line = -1)
par(mfrow=c(1,2))
DrawRateGraph2(resx[[1]][[1]], independent = T)
title("Independent", line = -1)
DrawRateGraph2(resx[[1]][[1]])
title("Dependent", line = -1)
DrawRateGraph(resx[[1]][[1]])
DrawRateGraphWithHist(resx[[1]][[1]])
DrawRateGraph(resx[[1]][[1]])
resx[[1]][[1]]
?Arrows
library(ape)
setwd("~/Documents/MPI/ClimateAndLanguage/PHOIBLE_Replication/analysis/")
source("fitPagel.r")
runDiscrete = function(tree,x,y, iQ, dQ){
# fit discrete
fit.ape = NA
try(fit.ape<-fitPagel(tree,x,y,iQ=iQ,dQ=dQ,method='ace'))
return(list(list(fit.ape,table(x,y),qx)))
}
# single-rate model
iQ<-matrix(c(0,1,2,0,3,0,0,2,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
# differet rates for complex -> simple in humid and dry conditions
dQ =matrix(c(0,1,2,0,3,0,0,5,4,0,0,1,0,4,3,0),4,4,byrow=TRUE)
tree = read.nexus("../data/grollemund_et_al2015-d-place.NEXUS")
tree.t = read.csv("../data/grollemund_et_al2015-d-place_Taxa.csv", stringsAsFactors = F)
tree$tip.label = tree.t[match(tree$tip.label, tree.t$taxon),]$glottocode
p = read.csv("../data/phoibleTonesAndHumidity.csv", stringsAsFactors = F)
load('../../Phylogenetics/GlottologTree/ANU_Data.rDat')
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
anu$glottocode = g[match(anu$iso, g$hid),]$id
anu = anu[!is.na(anu$glottocode),]
anu = anu[!anu$glottocode %in% p$Glottocode,]
names(anu)[names(anu) %in% c("Number.of.tones","glottocode")] = c("Tones","Glottocode")
comb = rbind(anu[,c("Glottocode","Tones",'specH.mean')],
p[,c("Glottocode","Tones",'specH.mean')])
tree = drop.tip(tree, tree$tip.label[!tree$tip.label %in% comb$Glottocode])
tones = comb[match(tree$tip.label, comb$Glottocode),]$Tones
names(tones) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
humidity = comb[match(tree$tip.label, comb$Glottocode),]$specH.mean
names(humidity) = comb[match(tree$tip.label, comb$Glottocode),]$Glottocode
tones.bin = c("simple","complex")[1+as.numeric(tones>=3)]
names(tones.bin) = names(tones)
# Estimate quantiles from whole distribution
quantilesToRun = seq(from=0.05,to=1,by=0.05)
quantiles = quantile(comb$specH.mean, quantilesToRun)
res = list()
for(qx in quantiles){
# set dry/humid by quantile
humidity.bin = c('humid','dry')[1+as.numeric(humidity < qx)]
names(humidity.bin) = names(humidity)
# run discrete
resx = runDiscrete(tree,tones.bin, humidity.bin,
iQ,dQ)
res[[length(res)+1]] = resx
}
